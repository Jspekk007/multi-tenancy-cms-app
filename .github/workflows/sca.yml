# .github/workflows/sca.yml
name: Reusable Software Component Analysis (Retire.js)

on:
  workflow_call:
    inputs:
      # Define which part of the project to scan
      scan-target:
        description: 'The target to scan ("root", "backend", or "frontend")'
        required: true
        type: string
      # Define the name for the artifact uploaded
      artifact-name:
        description: "Name for the uploaded report artifact"
        required: false
        type: string
        default: "retirejs-report" # Default name, caller can override
    outputs:
      # Output whether vulnerabilities were detected
      vulnerabilities-found:
        description: "Boolean indicating if vulnerabilities were found"
        value: ${{ jobs.scan.outputs.vulnerabilities-found }}
      # Output the exact name of the artifact uploaded
      report-artifact-name:
        description: "The name of the artifact containing the JSON report"
        value: ${{ jobs.scan.outputs.report-artifact-name }}

jobs:
  scan:
    name: Retire.js Scan (${{ inputs.scan-target }}) # Dynamic job name
    runs-on: ubuntu-latest
    # Define outputs for the job, which are then referenced in workflow outputs
    outputs:
      vulnerabilities-found: ${{ steps.check_report.outputs.vulnerabilities-found }}
      report-artifact-name: ${{ steps.set_artifact_name.outputs.artifact-name }}
    # Permissions might not be needed here anymore if commenting is moved out
    # permissions:
    #   contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Use latest version
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4 # Use latest version
        with:
          node-version: "22"
          cache: "yarn" # Enable caching

      # Install dependencies for the entire monorepo - necessary for retire to find packages
      - name: Install root dependencies
        run: yarn install --frozen-lockfile

      # Install Retire.js globally within the runner
      - name: Install Retire.js
        run: yarn global add retire@latest

      # Determine report file path based on input
      - name: Set Report Path
        id: set_paths
        run: |
          echo "report_file=retire-report-${{ inputs.scan-target }}.json" >> $GITHUB_OUTPUT

      # --- Run Retire.js Scan (Conditionally based on input) ---
      - name: Run Retire.js scan for ${{ inputs.scan-target }}
        id: retire_scan
        run: |
          SCAN_DIR="." # Default to root
          OUTPUT_PATH="${{ steps.set_paths.outputs.report_file }}"

          if [[ "${{ inputs.scan-target }}" == "backend" ]]; then
            SCAN_DIR="backend"
            # Install specific backend dependencies if needed (often retire works on lockfiles)
            # echo "Installing dependencies in backend..."
            # (cd backend && yarn install --frozen-lockfile)
            OUTPUT_PATH="../${{ steps.set_paths.outputs.report_file }}" # Output relative to root
            cd backend
          elif [[ "${{ inputs.scan-target }}" == "frontend" ]]; then
            SCAN_DIR="frontend"
            # Install specific frontend dependencies if needed
            # echo "Installing dependencies in frontend..."
            # (cd frontend && yarn install --frozen-lockfile)
            OUTPUT_PATH="../${{ steps.set_paths.outputs.report_file }}" # Output relative to root
            cd frontend
          fi

          echo "Running retire in $(pwd) saving to ${OUTPUT_PATH}"
          # Run retire, allowing it to fail without stopping the workflow (using || true)
          # We check the report content later to determine success/failure status
          retire --nodepath "$SCAN_DIR" --outputformat json --outputpath "$OUTPUT_PATH" --exitwith 0 || true

          # Ensure we are back at the root directory if we changed it
          if [[ "${{ inputs.scan-target }}" != "root" ]]; then
            cd ..
          fi

      # --- Check Report for Vulnerabilities ---
      - name: Check Report Content
        id: check_report
        run: |
          REPORT_FILE="${{ steps.set_paths.outputs.report_file }}"
          VULNS_FOUND="false" # Default to false

          if [[ ! -f "$REPORT_FILE" ]]; then
            echo "Report file '$REPORT_FILE' not found. Assuming no vulnerabilities."
          else
            # Check if the 'results' array within any 'data' item is non-empty
            # Adjust jq query if your vulnerability criteria differ
            COUNT=$(jq 'if .data then [.data[].results[] | select(.vulnerabilities | length > 0)] | length else 0 end' "$REPORT_FILE")

            echo "Found $COUNT vulnerabilities in $REPORT_FILE."
            if [[ "$COUNT" -gt 0 ]]; then
              VULNS_FOUND="true"
            fi
          fi

          echo "vulnerabilities-found=$VULNS_FOUND" >> $GITHUB_OUTPUT

      # Set the artifact name for output
      - name: Set Artifact Name
        id: set_artifact_name
        run: echo "artifact-name=${{ inputs.artifact-name }}-${{ inputs.scan-target }}" >> $GITHUB_OUTPUT

      # --- Upload Report Artifact ---
      - name: Upload Retire.js Report (${{ inputs.scan-target }})
        if: always() # Upload even if previous steps had issues (e.g., file not found)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set_artifact_name.outputs.artifact-name }} # Use dynamic name
          path: ${{ steps.set_paths.outputs.report_file }}
          if-no-files-found: warn # Don't fail if the report wasn't generated
