# .github/workflows/sast.yml
# Reusable SAST workflow using TruffleHog, dynamically targets frontend/backend/root

name: Reusable SAST (TruffleHog)

on:
  workflow_call:
    inputs:
      scan-target:
        description: 'The target to scan ("root", "backend", or "frontend")'
        required: true
        type: string
      artifact-name:
        description: 'The desired name for the uploaded report artifact (e.g., "frontend-trufflehog-report")'
        required: true
        type: string
    outputs:
      secrets-found:
        description: 'Boolean indicating if secrets were found ("true" or "false")'
        value: ${{ jobs.sast.outputs.secrets-found }}
      report-artifact-name:
        description: "The actual name of the artifact uploaded"
        # This now directly references the job output which will use the input
        value: ${{ jobs.sast.outputs.report-artifact-name }}

jobs:
  sast:
    name: TruffleHog Scan (${{ inputs.scan-target }})
    runs-on: ubuntu-latest
    outputs:
      secrets-found: ${{ steps.check_report.outputs.secrets-found }}
      # Directly use the input for the job output, as it's the intended artifact name
      report-artifact-name: ${{ inputs.artifact-name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set Report Filename and Paths
        id: set_paths
        run: |
          echo "report_filename=trufflehog-report-${{ inputs.scan-target }}.json" >> $GITHUB_OUTPUT
          SCAN_TARGET_DIR="." # Default to root
          if [[ "${{ inputs.scan-target }}" == "backend" ]]; then
            SCAN_TARGET_DIR="./backend"
          elif [[ "${{ inputs.scan-target }}" == "frontend" ]]; then
            SCAN_TARGET_DIR="./frontend"
          elif [[ "${{ inputs.scan-target }}" != "root" ]]; then
            echo "Error: Invalid scan target '${{ inputs.scan-target }}'"
            exit 1
          fi
          echo "scan_dir=$SCAN_TARGET_DIR" >> $GITHUB_OUTPUT

      - name: Run TruffleHog v3 filesystem scan using Docker
        id: trufflehog_scan
        run: |
          REPORT_FILENAME="${{ steps.set_paths.outputs.report_filename }}"
          OUTPUT_PATH="./$REPORT_FILENAME" # Relative path on the host
          SCAN_DIR="${{ steps.set_paths.outputs.scan_dir }}"

          echo "Scan target directory: $SCAN_DIR"
          echo "Report will be saved to host at: $OUTPUT_PATH (which is $GITHUB_WORKSPACE/$REPORT_FILENAME)"

          if [[ "$SCAN_DIR" != "." ]] && [[ ! -d "$SCAN_DIR" ]]; then
             echo "Error: Target directory '$SCAN_DIR' not found after checkout."
             exit 1
          fi

          ABS_SCAN_DIR="$(realpath "$SCAN_DIR")"
          ABS_OUTPUT_DIR="$(realpath .)" # Resolves to GITHUB_WORKSPACE

          echo "Running TruffleHog v3 filesystem scan using ghcr.io/trufflesecurity/trufflehog:latest."
          echo "Host scan directory (absolute): $ABS_SCAN_DIR (mounted to /src in container)"
          echo "Host output directory (absolute): $ABS_OUTPUT_DIR (mounted to /output in container)"
          echo "TruffleHog output will be redirected via sh -c to /output/$REPORT_FILENAME inside the container."

          # List files in scan directory for debugging
          echo "Files in scan directory:"
          ls -la "$ABS_SCAN_DIR"

          # Using ghcr.io/trufflesecurity/trufflehog:latest with enhanced detection
          docker run --rm \
            -v "$ABS_SCAN_DIR":/src \
            -v "$ABS_OUTPUT_DIR":/output \
            ghcr.io/trufflesecurity/trufflehog:latest \
            filesystem /src \
            --fail \
            --json \
            --debug \
            --no-verification > "$OUTPUT_PATH"

          # Debug: Show the contents of the report file
          echo "Report file contents:"
          cat "$OUTPUT_PATH"

          # Verify report creation on the host
          if [[ -f "$OUTPUT_PATH" ]]; then
            echo "✅ TruffleHog report created at $OUTPUT_PATH"
            # If TruffleHog finds no secrets, it should write "[]" via stdout.
            # This check handles if the file was created but is unexpectedly empty (0 bytes).
            if [[ ! -s "$OUTPUT_PATH" ]]; then
              echo "ℹ️ TruffleHog report file exists but is empty (0 bytes). Initializing with []."
              echo "[]" > "$OUTPUT_PATH"
            fi
          else
            echo "⚠️ Error: TruffleHog report was not created at $OUTPUT_PATH."
            echo "Creating an empty report '[]' to prevent downstream failures."
            echo "[]" > "$OUTPUT_PATH"
            # Consider failing the step if report creation is absolutely critical
            # exit 1
          fi

      - name: Check Report Content
        id: check_report
        run: |
          # Use the filename set in the first step
          FILE="${{ steps.set_paths.outputs.report_filename }}"
          SECRETS_FOUND="false"

          echo "Checking report content in file: $FILE"
          if [[ -f "$FILE" ]]; then
            # Ensure the file is not empty and contains valid JSON before querying
            if [[ -s "$FILE" ]] && jq -e . "$FILE" >/dev/null 2>&1; then
              # Count items in the top-level array. Trufflehog v3 output is a list of findings.
              COUNT=$(jq '. | length' "$FILE")
              if [[ "$COUNT" -gt 0 ]]; then
                echo "Secrets found: $COUNT"
                SECRETS_FOUND="true"
              else
                echo "No secrets found in the report."
              fi
            else
              echo "Report file is empty or not valid JSON. Assuming no secrets found."
            fi
          else
            echo "Report file $FILE not found. Assuming no secrets found."
            # This case should ideally be handled by the trufflehog_scan step creating an empty report
          fi
          echo "secrets-found=$SECRETS_FOUND" >> $GITHUB_OUTPUT

      - name: Upload TruffleHog Report
        uses: actions/upload-artifact@v4
        with:
          # Use the input artifact name directly
          name: ${{ inputs.artifact-name }}
          # Use the report_filename from set_paths step
          path: ${{ steps.set_paths.outputs.report_filename }}
          if-no-files-found: error # Fail if the report file is somehow missing
